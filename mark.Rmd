---
title: "Ebertowski_Maurycy_1_projekt1"
author: "MaurycyEbertowski"
date: "2024-11-23"
output:
  pdf_document: default
  html_document: default
editor_options:
  markdown:
    wrap: 72
---

```{r}
options(repos = c(CRAN = "https://cloud.r-project.org"))
library(dbscan)
library(sf)

punkty <- st_read("C:/Users/1/OneDrive/Pulpit/uni/stare/adp/ebertowski_XYTableToPoint.shp")
osiedla <- st_read("C:/Users/1/OneDrive/Pulpit/uni/stare/adp/osiedla.shp")
```

##### Sprawdzenie układu współrzędnych

```{r}
st_crs(punkty)
st_crs(osiedla)

plot(osiedla$geometry)
plot(punkty$geometry, pch=16, cex=0.4, add=TRUE)
```

### DBSCAN - Density Based Spatial Clustering of Applications with Noise

```{r}
punkty_df <- as.data.frame(st_coordinates(punkty))
db <- dbscan(punkty_df, eps=300, minPts=15)
db
punkty_df_fltr <- punkty_df[db$cluster != 0,] #filtrujemy szum
plot(osiedla$geometry, main="1 - eps=300, minPts=15")
points(punkty_df_fltr, pch=16, cex=0.5, col=rainbow(length(unique(db$cluster)))[db$cluster[db$cluster != 0]])
#rainbow(n) generuje wektor n równomiernie rozłożonych kolorów, wybieramy klastry != 0
```
##### Osiedla, na których wyznaczono klastry
```{r}
punkty_fltr_sf <- st_as_sf(punkty_df_fltr, coords = c("X", "Y"), crs = st_crs(osiedla))#zamiana punktów` na obiekt przestrzenny typu sf
punkty_osiedla <- st_join(punkty_fltr_sf, osiedla)# dopasowanie punktów do osiedli
nazwy_osiedli <- unique(punkty_osiedla$NAZWA_JEDN)
nazwy_osiedli

db <- dbscan(punkty_df, eps=300, minPts=25)
db
punkty_df_fltr <- punkty_df[db$cluster != 0,]
plot(osiedla$geometry, main="2 - eps=300, minPts=25")
points(punkty_df_fltr, pch=16, cex=0.5, col=rainbow(length(unique(db$cluster)))[db$cluster[db$cluster != 0]])
```
<br>

##### Osiedla, na których wyznaczono klastry
```{r}
punkty_fltr_sf <- st_as_sf(punkty_df_fltr, coords = c("X", "Y"), crs = st_crs(osiedla))
punkty_osiedla <- st_join(punkty_fltr_sf, osiedla)
nazwy_osiedli <- unique(punkty_osiedla$NAZWA_JEDN)
nazwy_osiedli

db <- dbscan(punkty_df, eps=200, minPts=15)
db
punkty_df_fltr <- punkty_df[db$cluster != 0,]
plot(osiedla$geometry, main="3 - eps=200, minPts=15")
points(punkty_df_fltr, pch=16, cex=0.5, col=rainbow(length(unique(db$cluster)))[db$cluster[db$cluster != 0]])
```
<br>

##### Osiedla, na których wyznaczono klastry
```{r}
punkty_fltr_sf <- st_as_sf(punkty_df_fltr, coords = c("X", "Y"), crs = st_crs(osiedla))
punkty_osiedla <- st_join(punkty_fltr_sf, osiedla)
nazwy_osiedli <- unique(punkty_osiedla$NAZWA_JEDN)
nazwy_osiedli

db <- dbscan(punkty_df, eps=200, minPts=25)
db
punkty_df_fltr <- punkty_df[db$cluster != 0,]
plot(osiedla$geometry, main="4 - eps=200, minPts=25")
points(punkty_df_fltr, pch=16, cex=0.5, col=rainbow(length(unique(db$cluster)))[db$cluster[db$cluster != 0]])
```
<br>

##### Osiedla, na których wyznaczono klastry
```{r}
punkty_fltr_sf <- st_as_sf(punkty_df_fltr, coords = c("X", "Y"), crs = st_crs(osiedla))
punkty_osiedla <- st_join(punkty_fltr_sf, osiedla)
nazwy_osiedli <- unique(punkty_osiedla$NAZWA_JEDN)
nazwy_osiedli
```

##### Punkt jest klasyfikowany jako core point jeśli w odległości eps jest co najmniej minPts punktów, punkt jest klasyfikowany jako border point jeśli należy do sąsiedztwa core point, ale sam nie spełnia kryteriów, pozostałe punkty są traktowane jako szum/noise. Klaster jest tworzony przez punkt rdzeniowy i wszystkie punkty osiągalne bezpośrednio z niego.
<br>

##### Porównując mapy 1 i 2 oraz 3 i 4 można zobaczyć, że większa wartość parametru minPts odfiltruje małe skupiska danych, a z tych większych wybierze najgęstszy obszar co widzimy na wykresach 1 i 2 lub podzieli go na oddzielne pomniejsze obszary co widać na wykresach 3 i 4. Zwiększenie wartości eps pokaże nam mniej zagęszczone obszary, a te duże o wysokiej gęstości połączy w jeden klaster co pokazują wykresy 1 i 3. Dodatkowo dołączy do takiego klastra dalej oddalone punkty co dobrze widać na wykresach 2 i 4.
<br>

<br>

#### Zalety DBSCAN:

##### -może znaleźć dowolnie ukształtowane klastry

##### -możliwość ustawienia prametrów eps i minPts, jeśli są dobrze zrozumiane i wiadomo czego chcemy się dowiedzieć o analizowanym zjawisku

##### -wydziela szum i jest odporny na wartości odstające
<br>

#### Wady DBSCAN:

##### -wymaga dobrego zrozumienia algorytmu, aby odpowiednio dostosować parametry

##### -punkty graniczne, które są osiągalne z kilku klastrów, będą przydzielone do któregoś z klastrów w zależności od kolejności przetwarzania danych
<br>

### HDBSCAN - Hierarchical Density Based Spatial Clustering of Applications with Noise

```{r}
hdb <- hdbscan(punkty_df, minPts=15)
hdb
punkty_df_fltr_hdb <- punkty_df[hdb$cluster != 0,]
plot(osiedla$geometry, main="5 - minPts=15")
points(punkty_df_fltr_hdb, pch=16, cex=0.5, col=rainbow(length(unique(hdb$cluster)))[hdb$cluster[hdb$cluster != 0]])
```
<br>

##### Osiedla, na których wyznaczono klastry
```{r}
punkty_fltr_sf <- st_as_sf(punkty_df_fltr_hdb, coords = c("X", "Y"), crs = st_crs(osiedla))
punkty_osiedla <- st_join(punkty_fltr_sf, osiedla)
nazwy_osiedli <- unique(punkty_osiedla$NAZWA_JEDN)
nazwy_osiedli

hdb <- hdbscan(punkty_df, minPts=25)
hdb
punkty_df_fltr_hdb <- punkty_df[hdb$cluster != 0,]
plot(osiedla$geometry, main="6 - minPts=25")
points(punkty_df_fltr_hdb, pch=16, cex=0.5, col=rainbow(length(unique(hdb$cluster)))[hdb$cluster[hdb$cluster != 0]])
```
<br>

##### Osiedla, na których wyznaczono klastry
```{r}
punkty_fltr_sf <- st_as_sf(punkty_df_fltr_hdb, coords = c("X", "Y"), crs = st_crs(osiedla))
punkty_osiedla <- st_join(punkty_fltr_sf, osiedla)
nazwy_osiedli <- unique(punkty_osiedla$NAZWA_JEDN)
nazwy_osiedli
```

##### Algorytm tworzący hierarchię klastrów o różnej gęstości. Zaczyna od tworzenia małych klastrów, a następnie stopniowo zwiększa eps i łączy je w większe grupy szukając wartości parametru, która daje najwększą stabilność. Stabilność klastra oznacza, że grupa punktów pozostaje w tej samej grupie, przy zmieniających się kryteriach. Ostatecznie algorytm zwraca zestaw klastrów o różnej gęstości, które najlepiej wpasowują się do zestawu danych.
<br>

#### Zalety HDBSCAN:

##### -bardziej elastyczny, może wykrywać klastry w danych, które DBSCAN może zignorować lub pomylić z szumem

##### -mniej wrażliwy na wybór parametrów
<br>

#### Wady HDBSCAN

##### -wyższa złożoność obliczeniowa
<br>

<br>

##### Zwiększając parametr minPts, hdbscan podzieli nam duże, gęste skupiska danych na pomniejsze, te rzadsze które znajdują się blisko siebie połączy w jeden obszar, a te które są małe, rzadkie i daleko od innych skupisk zostaną odfiltrowane.
<br>

##### Porównując mapy z zastosowanymi algorytmami dbscan i hdbscan widzimy, że ten drugi pokaże nam więcej informacji. Jest on również prostszy w użyciu lecz wymaga podstawowej wiedzy na temat jego działania, aby go dobrze zinterpretować. Jeżeli zależy nam na stałych parametrach dla całej mapy to użyteczny będzie dbscan, lecz trzeba być pewnym co się chce przeanalizować w celu odpowiedniego ustawienia wartości eps i minPts.